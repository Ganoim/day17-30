--계정 생성
/*
CREATE user C##(일반사용자)아이디 IDENTIFIED BY 비밀번호
*/
ALTER SESSION SET "_ORACLE_SCRIPT" = TRUE; -- 공통 사용자 규칙 해제

CREATE user JGH_TEST IDENTIFIED BY "1234"; -- 전송(F9)
-- 권한 부여 GRANT 권한 TO 아이디
GRANT CREATE SESSION TO JGH_TEST;
-- 권한 회수 REVOKE 권한 FROM 아이디
REVOKE CREATE SESSION FROM JGH_TEST;
-- 계정 삭제 DROP USER 아이디
DROP USER JGH_TEST;

-- DBA 계정생성
CREATE USER JGH_DBA IDENTIFIED BY "1111";
-- DBA 권한부여
GRANT DBA TO JGH_DBA;


-- 테이블 생성 CREATE TABLE 이름(컬럼명 타입); NVARCHAR2(글자수)-문자열데이터타입
CREATE TABLE MEMBERS( -- 회원정보 테이블
    MID NVARCHAR2(5), -- 아이디 저장, 문자 최대 5글자까지
    MPW NVARCHAR2(5), -- 비밀번호
    MNAME NVARCHAR2(5)
);
DESC MEMBERS; -- 테이블 구조 확인

SELECT * FROM MEMBERS; -- 테이블 조회(*-모든것을 조회)
INSERT INTO MEMBERS VALUES('ID01', 'PW01', '회원01');
INSERT INTO MEMBERS VALUES('ID02', 'PW02', '회원02');
INSERT INTO MEMBERS VALUES('ID03', 'PW03', '회원03');
SELECT * FROM MEMBERS; 

/* 테이블 생성
CREATE TABLE 테이블이름(
    컬러명1 데이터타입,
    컬러명2 데이터타입,
    컬러명3 데이터타입
); -- Table MEMBERS이(가) 생성되었습니다.
*/

/* 데이터타입
문자형 - 고정형: CHAR(N=글자수 N이 없으면 바이트)
        가변형: VARCHAR(VAR가 붙으면 가변형), NVARCHAR2(5) - (N=글자수)
숫자형 - NUMBER: 모든자리수 가능(제한x), NUMBER(3): 3자리수까지만, NUMBER(3,2): 앞자리는 3자리수 ','다음은 소수점2자리수
날짜형 - DATE // 연-월-일 시:분:초
            YYYY-MM-DD HH24(24:0~24시, 없으면 12시):MI:SS
*/

/*
CREATE - INSERT
READ   - SELECT
UPDATE - UPDATE(컬럼의 저장되어있는 데이터를 수정)
DELETE - DELETE
*/

------Day02  

CREATE TABLE CHARTEST_TBL(
    CHARCOL1 CHAR(5),
    NCHARCOL2 NCHAR(5)
);
/* INSERT 
INSERT INTO 테이블명(컬럼명1, 컬럼명2) 
VALUES(데이터1, 데이터2);

문자는 ''안에 작성
*/
INSERT INTO CHARTEST_TBL(CHARCOL1, NCHARCOL2)
VALUES('ABCDE', 'ABCDE');

SELECT * FROM CHARTEST_TBL;

INSERT INTO CHARTEST_TBL(CHARCOL1, NCHARCOL2)
VALUES('가나다라마', 'ABCDE'); -- 오류 ORA-12899: "JGH_DBA"."CHARTEST_TBL"."CHARCOL1" 열에 대한 값이 너무 큼(실제: 15, 최대값: 5)

INSERT INTO CHARTEST_TBL(CHARCOL1, NCHARCOL2)
VALUES('ABCDE', '가나다라마');

CREATE TABLE NUMBERTEST_TBL(
    COL1 NUMBER,
    COL2 NUMBER(3),
    COL3 NUMBER(3, 2) -- 1.23
);
INSERT INTO NUMBERTEST_TBL
VALUES(123, 123, 1.23);
INSERT INTO NUMBERTEST_TBL
VALUES(12345678, 123, 1.23);
INSERT INTO NUMBERTEST_TBL
VALUES(12345678, 123345678, 1.23); -- 오류 ORA-01438: 이 열에 대해 지정된 전체 자릿수보다 큰 값이 허용됩니다.
INSERT INTO NUMBERTEST_TBL
VALUES(12334567, 123, 1.2345678); -- 입력성공(1.23만 나오고 나머지는 짤림)
SELECT * FROM NUMBERTEST_TBL;
INSERT INTO NUMBERTEST_TBL
VALUES(123, 123, 12.3); -- ORA-01438: 이 열에 대해 지정된 전체 자릿수보다 큰 값이 허용됩니다. - 소수점 1자리여서 규칙에 어긋남

/* 날짜형 데이터 */
CREATE TABLE DATETEST_TBL(
    COL1 DATE
);
-- 시스템 DATE 입력
INSERT INTO DATETEST_TBL VALUES(SYSDATE);
SELECT * FROM DATETEST_TBL;

INSERT INTO DATETEST_TBL VALUES('2023/05/19');
INSERT INTO DATETEST_TBL VALUES('2023-06-19');
INSERT INTO DATETEST_TBL VALUES('2023-06-19 23:50:48');
INSERT INTO DATETEST_TBL VALUES('20230519');
-- TO_DATE( '날짜로 변경할 문자', '날짜확인방법' ) : 문자형 >> 날짜형으로 변환
INSERT INTO DATETEST_TBL VALUES( TO_DATE('2023-07-19 23:50:48', 'YYYY-MM-DD HH24:MI:SS') );
SELECT * FROM DATETEST_TBL;
-- TO_CHAR( '문자로 변경할 날짜', '변경할 범위' );

SELECT TO_CHAR (COL1, 'YYYY/MM/DD')
FROM DATETEST_TBL;

/* 테이블변경 ALTER(변경)
ALTER TABLE 테이블이름 
[ADD(추가), RENAME(이름변경), MODIFY(타입변경), DROP(삭제)]
*/
/* 새로운 컬럼 추가 
ALTER TABLE 테이블이름 
ADD 컬럼명 데이터타입;
*/
CREATE TABLE ALTER_TBL(
    COL1 NUMBER
);
-- ALTER_TBL 테이블에 컬럼이름은 NAME, 데이터타입은 NVARCHAR2(5) 컬럼 추가
ALTER TABLE ALTER_TBL ADD NAME NVARCHAR2(5);
/* 컬럼 이름 변경 
ALTER TABLE 테이블이름
RENAME COLUMN 현재컬럼명 TO 바꿀컬럼명;
*/
-- ALTER_TBL 테이블에 COL1 컬럼명을 AGE로 변경
ALTER TABLE ALTER_TBL RENAME COLUMN COL1 TO AGE;
SELECT * FROM ALTER_TBL;
DESC ALTER_TBL; -- 테이블 구조확인

/* 컬럼의 데이터 타입 변경
ALTER TABLE 테이블이름
MODIFY 컬러명 데이터타입;
*/
-- ALTER_TBL 테이블에 컬럼명 EMAIL 데이터타입 NUMBER 컬럼추가
ALTER TABLE ALTER_TBL ADD EMAIL NUMBER;
-- ALTER_TBL 테이블의 EMAIL 컬럼의 데이터타입을 문자형 최대 20글자까지
ALTER TABLE ALTER_TBL MODIFY EMAIL NVARCHAR2(20);
DESC ALTER_TBL;

/* 컬럼 삭제 
ALTER TABLE 테이블이름
DROP COLUMN 컬럼명;
*/
-- ALTER_TBL 테아블에 AGE 컬럼을 삭제
ALTER TABLE ALTER_TBL DROP COLUMN AGE;

/* 제약조건 
 - PRIMARY KEY
 - FOREIGE KEY
 - UNIQUE
 - NOT NULL
 - CHECK 
 - DEFAULT
*/
/* UNIQUE : 테이블의 특정한 컬럼 부여, 중복되는 값이 입력되지 않도록 방지 */
CREATE TABLE MEMBERS(
     MID NVARCHAR2(20),
     MPW NVARCHAR2(20),
     MNAME NVARCHAR2(5),
     MEMAIL NVARCHAR2(20)
);
-- 회원정보 입력
INSERT INTO MEMBERS(MID, MPW, MNAME, MEMAIL)
VALUES('JGH', '1111', '전관호', 'JGH1111@ICIA.CO.KR');
INSERT INTO MEMBERS(MID, MPW, MNAME, MEMAIL)
VALUES('JGH', '1111', '인천일보', 'JGH1111@ICIA.CO.KR');
SELECT * FROM MEMBERS;
/* 테이블에 제약조건 부여 
ALTER TABLE 테이블이름
ADD CONSTRAINT 식별이름 제약조건종류 부여할컬럼명;
*/
-- MEMBERS 테이블의 MID 컬럼에 UNIQUE 제약조건 부여
ALTER TABLE MEMBERS ADD CONSTRAINT UK_MEM_MID UNIQUE (MID); -- 중복된 데이터가 존재해서 오류 발생
-- ORA-02299: 제약 (JGH_DBA.UK_MEM_MID)을 사용 가능하게 할 수 없음 - 중복 키가 있습니다(이미 MID중복된값이 들어가있어서 오류)
DELETE FROM MEMBERS; -- DELETE - 테이블에 데이터를 삭제

ALTER TABLE MEMBERS ADD CONSTRAINT UK_MEM_MID UNIQUE (MID);
INSERT INTO MEMBERS(MID, MPW, MNAME, MEMAIL)
VALUES('JGH', '1111', '전관호', 'JGH1111@ICIA.CO.KR'); -- 입력성공
INSERT INTO MEMBERS(MID, MPW, MNAME, MEMAIL)
VALUES('JGH', '1111', '인천일보', 'JGH1111@ICIA.CO.KR'); -- 입력실패
-- ORA-00001: 무결성 제약 조건(JGH_DBA.UK_MEM_MID)에 위배됩니다

-- MEMBERS 테이블의 MEMAIL 컬럼에 UNIQUE 제약조건 부여
ALTER TABLE MEMBERS ADD CONSTRAINT UK_MEM_MEMAIL UNIQUE(MEMAIL);
INSERT INTO MEMBERS(MID, MPW, MNAME, MEMAIL)
VALUES('JJJ', '1111', '전관호', 'JGH1111@ICIA.CO.KR');
-- ORA-00001: 무결성 제약 조건(JGH_DBA.UK_MEM_MEMAIL)에 위배됩니다


-----day03

/* 테아블을 생성하면서 제약조건 부여1 */
CREATE TABLE MEMBERS2(
     MID NVARCHAR2(20) CONSTRAINT UK_MEM2_MID UNIQUE ,  --아이디
     MPW NVARCHAR2(20),  --비밀번호
     MNAME NVARCHAR2(5), --이름
     MEMAIL NVARCHAR2(20)--이메일
);
/* 테이블을 생성하면서 제약조건 부여2 */
CREATE TABLE MEMBERS3(
     MID3 NVARCHAR2(20),    --아이디
     MPW3 NVARCHAR2(20),    --비밀번호
     MNAME3 NVARCHAR2(5),   --이름
     MEMAIL3 NVARCHAR2(20), --이메일
     CONSTRAINT UK_MEM3_MID UNIQUE(MID3)
);
/* UNIQUE : 테이블의 특정한 컬럼 부여, 중복되는 값이 입력되지 않도록 방지 */
INSERT INTO MEMBERS3(MID3, MPW3, MNAME3, MEMAIL3)
VALUES('JGH', '1111', '전관호', 'QWE123@ICIA.CO.KR' ); 
INSERT INTO MEMBERS3(MID3, MPW3, MNAME3, MEMAIL3)
VALUES('JGH', '1234', '회원02', '회원02@ICIA.CO.KR' ); 

--MID 컬럼에 NULL값 입력
INSERT INTO MEMBERS3(MPW3, MNAME3, MEMAIL3)
VALUES('1234', '회원03', '회원03@ICIA.CO.KR' );
INSERT INTO MEMBERS3(MID3, MPW3, MNAME3, MEMAIL3)
VALUES(NULL, '1234', '회원04', '회원04@ICIA.CO.KR' ); 
SELECT * FROM MEMBERS3;

/* NOT NULL : 지정된 컬럼에 NULL값울 허용하지 않는다.(옵션-안쓰면 NULL값을 허용) */
CREATE TABLE MEMBERS(
     MID NVARCHAR2(20) CONSTRAINT NN_MEM_MID NOT NULL, --아이디
     MPW NVARCHAR2(20),     --비밀번호
     MNAME NVARCHAR2(5),    --이름
     MEMAIL NVARCHAR2(20),  --이메일
     CONSTRAINT UK_MEM_MID UNIQUE(MID)
);
INSERT INTO MEMBERS(MID, MPW, MNAME, MEMAIL)
VALUES(NULL, '1234', '회원01', '회원01@ICIA.CO.KR' ); --ORA-01400: NULL을 ("JGH_DBA"."MEMBERS"."MID") 안에 삽입할 수 없습니다

DROP TABLE MEMBERS;
CREATE TABLE MEMBERS(
     MID NVARCHAR2(20),     --아이디
     MPW NVARCHAR2(20),     --비밀번호
     MNAME NVARCHAR2(5),    --이름
     MEMAIL NVARCHAR2(20),  --이메일
     CONSTRAINT UK_MEM_MID UNIQUE(MID)
);
ALTER TABLE MEMBERS 
MODIFY MID NOT NULL;
DESC MEMBERS;
--UNIQUE 제약조건삭제
ALTER TABLE MEMBERS DROP CONSTRAINT UK_MEM_MID;
--NOT NULL=>NULL
ALTER TABLE MEMBERS MODIFY MID NULL;

/* 제약조건 
 - UNIQUE : 테이블의 특정한 컬럼 부여, 중복되는 값이 입력 되지 않도록 방지
 - NOT NULL : 트정 컬럼에 NULL값이 입력 되지 않도록 방지
 - PRIMARY KEY : UNIQUE + NOT NULL (테이블에 한번만 부여할 수 있음)
                 테이블에서 레코드를 구분 지을 수 있는 유일한 컬럼에 부여
*/
DROP TABLE MEMBERS;
CREATE TABLE MEMBERS(
     MID NVARCHAR2(20),     --아이디
     MPW NVARCHAR2(20),     --비밀번호
     MNAME NVARCHAR2(5),    --이름
     MEMAIL NVARCHAR2(20)  --이메일
);
-- MID 컬럼에 PRIMARY KEY 부여
ALTER TABLE MEMBERS ADD CONSTRAINT PK_MEM_MID PRIMARY KEY(MID);
INSERT INTO MEMBERS(MID, MPW, MNAME, MEMAIL)
VALUES('JGH', '1111', '전관호', 'QWE123@ICIA.CO.KR');
INSERT INTO MEMBERS(MID, MPW, MNAME, MEMAIL) -- UNIQUE 확인
VALUES('JGH', '1234', '회원01', '회원01@ICIA.CO.KR'); --오류: ORA-00001: 무결성 제약 조건(JGH_DBA.PK_MEM_MID)에 위배됩니다

INSERT INTO MEMBERS(MID, MPW, MNAME, MEMAIL) -- NOT NULL 확인
VALUES(NULL, '1234', '회원02', '회원02@ICIA.CO.KR'); -- ORA-01400: NULL을 ("JGH_DBA"."MEMBERS"."MID") 안에 삽입할 수 없습니다
--이메일 컬럼에 UNIQUE 제약 조건 부여
ALTER TABLE MEMBERS ADD CONSTRAINT UK_MEM_MEMAIL UNIQUE(MEMAIL);
INSERT INTO MEMBERS(MID, MPW, MNAME, MEMAIL)
VALUES('ID01', '1234', '회원01', NULL);
INSERT INTO MEMBERS(MID, MPW, MNAME, MEMAIL)
VALUES('ID02', '1234', '회원02', NULL); -- UNIQUE는 NULL값이 들어감

-- MNAME에 PRIMARY KEY 부여
ALTER TABLE MEMBERS ADD CONSTRAINT PK_MEM_MNAME PRIMARY KEY(MNAME); -- ORA-02260: 테이블에는 하나의 기본 키만 가질 수 있습니다.
ALTER TABLE MEMBERS ADD CONSTRAINT UK_MEM_MNAME UNIQUE(MNAME);
SELECT * FROM MEMBERS;

/* DEFAULT : 특정하 컬럼에 값이 입력되지 않을 경우 기본으로 입력되는 값을 설정 */
DROP TABLE MEMBERS;
CREATE TABLE MEMBERS(
     MID NVARCHAR2(20),     --아이디
     MPW NVARCHAR2(20),     --비밀번호
     MNAME NVARCHAR2(20) DEFAULT '이름없음',   --이름
     MAGE NUMBER            --나이
);
INSERT INTO MEMBERS(MID, MPW, MAGE)
VALUES('ID01', '1234', 10);
INSERT INTO MEMBERS(MID, MAGE)
VALUES('ID01', 10);
SELECT * FROM MEMBERS;
INSERT INTO MEMBERS(MID, MPW, MNAME, MAGE)
VALUES('ID02', '1234', DEFAULT, 20);

/* 나이 컬럼에 기본값 1 설정 */
ALTER TABLE MEMBERS MODIFY MAGE DEFAULT 1;

/* CHECK : 특정한 컬럼에 입력할 수 있는 값에 대한 조건 부여 */
DROP TABLE MEMBERS;
CREATE TABLE MEMBERS(
     MID NVARCHAR2(20),     --아이디
     MPW NVARCHAR2(20),     --비밀번호
     MNAME NVARCHAR2(20),   --이름
     MAGE NUMBER,            --나이
     CONSTRAINT CK_MEM_MAGE CHECK(MAGE > 10) 
);
INSERT INTO MEMBERS(MAGE)
VALUES(30); -- 1 행 이(가) 삽입되었습니다.
SELECT * FROM MEMBERS;
INSERT INTO MEMBERS(MAGE)
VALUES(5); -- ORA-02290: 체크 제약조건(JGH_DBA.CK_MEM_MAGE)이 위배되었습니다

/* 제약조건 
 - PRIMARY KEY
 - UNIQUE
 - NOT NULL
 - FOREIGN(E) KEY
 - CHECK 
 - DEFAULT
*/

-- FOREIGN KEY
DROP TABLE MEMBERS;
CREATE TABLE MEMBERS(
     MID NVARCHAR2(20),    --아이디
     MPW NVARCHAR2(20)     --비밀번호
);
-- MID 컬럼에 PRIMARY KEY 부여
ALTER TABLE MEMBERS
ADD CONSTRAINT PK_MEM_MID PRIMARY KEY(MID);

INSERT INTO MEMBERS(MID, MPW)
VALUES('JGH', '1111'); -- 회원 정보 입력
INSERT INTO MEMBERS(MID, MPW)
VALUES('ABC', '1234'); 
SELECT * FROM MEMBERS;

DROP TABLE LOGINCHECK;
CREATE TABLE LOGINCHECK( -- 회원의 로그인 시간
    MID NVARCHAR2(20),   -- 회원 아이디 - MEMBERS 테이블의 MID컬럼의 값
    LOGINTIME DATE       -- 로그인 시간
);
-- LOGINCHECK테이블에 MID 컬럼에 FOREIGN KEY 지정
ALTER TABLE LOGINCHECK
ADD CONSTRAINT FK_LOG_MID FOREIGN KEY( MID )
REFERENCES MEMBERS(MID);

-- FOREIGN KEY : MEMBERS테이블에 있는 데이터만 LOGINCHECK테이블에 쓸 수 있음
INSERT INTO LOGINCHECK(MID, LOGINTIME)
VALUES('ICIA', SYSDATE); -- ORA-02291: 무결성 제약조건(JGH_DBA.FK_LOG_MID)이 위배되었습니다- 부모 키가 없습니다

INSERT INTO LOGINCHECK(MID, LOGINTIME)
VALUES('JGH', SYSDATE); -- 입력가능
INSERT INTO LOGINCHECK(MID, LOGINTIME)
VALUES('ABC', SYSDATE); -- 입력가능
SELECT * FROM LOGINCHECK;


-----day04

/* FOREIGN KEY : 외래키 */
-- 기본키로 설정된 것만 외래키로 설정할 수 있고
/* 상품정보 테이블 - GOODS
    상품이름 - GNAME 문자 20글자까지, PRIMARY KEY로 지정
    상품가격 - GPRICE 숫자타입
    상춤브랜드 - GBRAND 문자타입 20글자까지 - NOT NULL
*/

CREATE TABLE GOODS(
    GNAME NVARCHAR2(20),
    GPRICE NUMBER,
    GBRAND NVARCHAR2(20)
);
-- 제약조건 부여
ALTER TABLE GOODS
ADD CONSTRAINT PK_GOODS_GNAME PRIMARY KEY(GNAME)
MODIFY GBRAND NOT NULL;
-- 상품정보입력
INSERT INTO GOODS(GNAME, GPRICE, GBRAND)
VALUES('7800X3D', '600000', 'AMD' );
INSERT INTO GOODS(GNAME, GPRICE, GBRAND)
VALUES('RTX4090', '2300000', 'NVIDIA' );
INSERT INTO GOODS(GNAME, GPRICE, GBRAND)
VALUES('RTX4070', '750000', 'NVIDIA' );

/* 주문내역 테이블 
    상품이름, 가격, 구매자, 주문일시, 배송지, 주문수량
    상품이름 문자20자
*/
CREATE  TABLE ORDERLIST(
    GNAME NVARCHAR2(20),     -- 상품이름
    GPRICE NUMBER,           -- 상품가격
    CUSTOMER NVARCHAR2(10),  -- 구매자
    ODDATE DATE,             -- 주문일시
    ADDRESS NVARCHAR2(50),    -- 배송지
    QTY NUMBER               -- 주문수
);
-- FOREIGN KEY : 외래키 지정
ALTER TABLE ORDERLIST
ADD CONSTRAINT FK_ODLIST_GNAME FOREIGN KEY(GNAME)
REFERENCES GOODS(GNAME);
-- 주문 정보 입력
INSERT INTO ORDERLIST(GNAME, GPRICE, CUSTOMER, ODDATE, ADDRESS, QTY)
VALUES('7800X3D', 600000, '전관호', SYSDATE, '인천', 1);
INSERT INTO ORDERLIST(GNAME, GPRICE, CUSTOMER, ODDATE, ADDRESS, QTY)
VALUES('7800X3D', 600000, '홍길동', SYSDATE, '인천', 1);
INSERT INTO ORDERLIST(GNAME, GPRICE, CUSTOMER, ODDATE, ADDRESS, QTY)
VALUES('RTX4070', 750000, 'ICIA', SYSDATE, '인천일보아카데미', 1);
INSERT INTO ORDERLIST(GNAME, GPRICE, CUSTOMER, ODDATE, ADDRESS, QTY)
VALUES('RTX4090', 2300000, 'ICAI', SYSDATE, '인천일보아카데미', 1);

SELECT * FROM ORDERLIST;

INSERT INTO ORDERLIST(GNAME, GPRICE, CUSTOMER, ODDATE, ADDRESS, QTY)
VALUES('사이다', 1000, '전관호', SYSDATE, '인천', 1); -- ORA-02291: 무결성 제약조건(JGH_DBA.FK_ODLIST_GNAME)이 위배되었습니다- 부모 키가 없습니다

-- 1. ORDERLIST 테이블의 상품이름
SELECT GNAME FROM ORDERLIST;

/*
CREATE - INSERT : 데이터 입력
READ   - SELECT : 테이터 조회
UPDATE - UPEATE : 데이터 수정
DELETE - DELETE : 데이터 삭제
*/
/* INSERT문
   INSERT INTO 테이블이름( 컬럼명1, 컬럼명2,....컬러명N )
   VALUES( 컬럼1에 저장할 값, 컬럼2에 저장할 값,.... );
*/
DROP TABLE ORDERLIST;
DROP TABLE GOODS;
CREATE TABLE GOODS(
    GNAME NVARCHAR2(20),
    GPRICE NUMBER,
    GBRAND NVARCHAR2(20)
);
INSERT INTO GOODS(GNAME, GPRICE, GBRAND)
VALUES('상품명1', 10000, '브랜드1');
INSERT INTO GOODS(GNAME, GPRICE, GBRAND)
VALUES('브랜드2', 10000, '상품명2');
INSERT INTO GOODS( GPRICE, GBRAND, GNAME)
VALUES( 10000, '브랜드3', '상품명3');
INSERT INTO GOODS(GNAME, GBRAND)
VALUES('상품명4', '브랜드4');
INSERT INTO GOODS(GBRAND)
VALUES('브랜드5');
-- 컬럼명을 명시X VALUES항목은 테이블의 모든 컬럼값
INSERT INTO GOODS
VALUES('상품명6', 20000, '브랜드6'); -- GNAME, GPRICE, GBRAND
SELECT * FROM GOODS;
SELECT * FROM GOODS WHERE GPRICE = 10000;

/* 데이터 조회 - SELECT 
[5]SELECT 조회할컬럼명, 조회할컬럼명2...
[1]FROM 테이블명 
[2]WHERE 조건
[3]GROUP BY 그룹을 나눌 컬럼
[4]HAVING 나눠진 그룹에 부여할 조건
[6]ORDER BY 정렬기준컬럼
*/

/* 데이터 수정 : UPDATE
    UPDATE 테이블명
    SET 컬럼명1 = 수정할 데이터, 컬럼명2 = 수정할 데이터
    WHERE 데이터를 수정할 레코드를 선별할 조건
*/
SELECT * FROM GOODS;

UPDATE GOODS 
SET GPRICE = 1500; -- 6개 행 이(가) 업데이트되었습니다.

UPDATE GOODS
SET GPRICE = 10000
WHERE GNAME = '상품명1'; -- 1 행 이(가) 업데이트되었습니다.

UPDATE GOODS
SET GPRICE = 15000, GBRAND = '브랜드명수정'
WHERE GNAME = '상품명1';

/* 데이터 삭제 : DELETE
    DELETE FROM 테이블명
    WHERE 삭제할 레코드를 선별하는 조건
*/              
DELETE FROM GOODS
WHERE GNAME = '상품명1'; -- 1 행 이(가) 삭제되었습니다.
DELETE FROM GOODS; -- 테이블은 남아있고 모든 레코드가 지워짐(모든 행 삭제)

SELECT * FROM GOODS;
CREATE TABLE GOODS(
    GNAME NVARCHAR2(20),
    GPRICE NUMBER,
    GBRAND NVARCHAR2(20)
);
INSERT INTO GOODS(GNAME, GPRICE, GBRAND)
VALUES('상품명1', 10000, '브랜드1');
INSERT INTO GOODS(GNAME, GPRICE, GBRAND)
VALUES('브랜드2', 10000, '상품명2');
SELECT * FROM GOODS; -- 레코드 2개
ROLLBACK;            -- 이전 상태로(테이블만 만든상태)
SELECT * FROM GOODS; -- 레코드 없음

INSERT INTO GOODS(GNAME, GPRICE, GBRAND)
VALUES('상품명1', 10000, '브랜드1');
INSERT INTO GOODS(GNAME, GPRICE, GBRAND)
VALUES('브랜드2', 10000, '상품명2');
COMMIT;  -- 예정되어있는 데이터 저장(확정)
ROLLBACK;-- 커밋을 한 시점으로 롤백(되돌림)
SELECT * FROM GOODS; -- 레코드 2개

INSERT INTO GOODS(GNAME, GPRICE, GBRAND)
VALUES('상품명3', 30000, '브랜드3');
ROLLBACK;
SELECT * FROM GOODS;

CREATE TABLE TESTTBL01(COL01 NUMBER); -- CREATE, ALTER, DROP은 자동으로 커밋된다
ROLLBACK;
SELECT * FROM TESTTBL01;


-----day05
DROP TABLE DEPT;
CREATE TABLE DEPT
    (DEPTNO NUMBER(2) CONSTRAINT PK_DEPT PRIMARY KEY,
	DNAME VARCHAR2(14) ,
	LOC VARCHAR2(13) ) ;
DROP TABLE EMP;
CREATE TABLE EMP
       (EMPNO NUMBER(4) CONSTRAINT PK_EMP PRIMARY KEY,
	ENAME VARCHAR2(10),
	JOB VARCHAR2(9),
	MGR NUMBER(4),
	HIREDATE DATE,
	SAL NUMBER(7,2),
	COMM NUMBER(7,2),
	DEPTNO NUMBER(2) CONSTRAINT FK_DEPTNO REFERENCES DEPT);
INSERT INTO DEPT VALUES
	(10,'ACCOUNTING','NEW YORK');
INSERT INTO DEPT VALUES (20,'RESEARCH','DALLAS');
INSERT INTO DEPT VALUES
	(30,'SALES','CHICAGO');
INSERT INTO DEPT VALUES
	(40,'OPERATIONS','BOSTON');
INSERT INTO EMP VALUES
(7369,'SMITH','CLERK',7902,to_date('17-12-1980','dd-mm-yyyy'),800,NULL,20);
INSERT INTO EMP VALUES
(7499,'ALLEN','SALESMAN',7698,to_date('20-2-1981','dd-mm-yyyy'),1600,300,30);
INSERT INTO EMP VALUES
(7521,'WARD','SALESMAN',7698,to_date('22-2-1981','dd-mm-yyyy'),1250,500,30);
INSERT INTO EMP VALUES
(7566,'JONES','MANAGER',7839,to_date('2-4-1981','dd-mm-yyyy'),2975,NULL,20);
INSERT INTO EMP VALUES
(7654,'MARTIN','SALESMAN',7698,to_date('28-9-1981','dd-mm-yyyy'),1250,1400,30);
INSERT INTO EMP VALUES
(7698,'BLAKE','MANAGER',7839,to_date('1-5-1981','dd-mm-yyyy'),2850,NULL,30);
INSERT INTO EMP VALUES
(7782,'CLARK','MANAGER',7839,to_date('9-6-1981','dd-mm-yyyy'),2450,NULL,10);
INSERT INTO EMP VALUES
(7788,'SCOTT','ANALYST',7566,to_date('13-JUL-87')-85,3000,NULL,20);
INSERT INTO EMP VALUES
(7839,'KING','PRESIDENT',NULL,to_date('17-11-1981','dd-mm-yyyy'),5000,NULL,10);
INSERT INTO EMP VALUES
(7844,'TURNER','SALESMAN',7698,to_date('8-9-1981','dd-mm-yyyy'),1500,0,30);
INSERT INTO EMP VALUES
(7876,'ADAMS','CLERK',7788,to_date('13-JUL-87')-51,1100,NULL,20);
INSERT INTO EMP VALUES
(7900,'JAMES','CLERK',7698,to_date('3-12-1981','dd-mm-yyyy'),950,NULL,30);
INSERT INTO EMP VALUES
(7902,'FORD','ANALYST',7566,to_date('3-12-1981','dd-mm-yyyy'),3000,NULL,20);
INSERT INTO EMP VALUES
(7934,'MILLER','CLERK',7782,to_date('23-1-1982','dd-mm-yyyy'),1300,NULL,10);
DROP TABLE BONUS;
CREATE TABLE BONUS
	(
	ENAME VARCHAR2(10)	,
	JOB VARCHAR2(9)  ,
	SAL NUMBER,
	COMM NUMBER
	) ;
DROP TABLE SALGRADE;
CREATE TABLE SALGRADE
      ( GRADE NUMBER,
	LOSAL NUMBER,
	HISAL NUMBER );
INSERT INTO SALGRADE VALUES (1,700,1200);
INSERT INTO SALGRADE VALUES (2,1201,1400);
INSERT INTO SALGRADE VALUES (3,1401,2000);
INSERT INTO SALGRADE VALUES (4,2001,3000);
INSERT INTO SALGRADE VALUES (5,3001,9999);
COMMIT;

SELECT * FROM EMP;
SELECT * FROM DEPT;
/* SELECT문
    SELECT 컬럼명1, 컬럼명2
    FROM 테이블명
    WHERE 조건
*/
-- EMP 테이블의 모든 컬럼
SELECT * 
FROM EMP;
-- 직원번호(EMPNO), 직원이름(ENAME) 조회
SELECT EMPNO, ENAME 
FROM EMP;
-- 부서번호가 10번인 직원들의 모든 정보를 조회
SELECT * 
FROM EMP
WHERE DEPTNO = 10;
-- 직무(JOB)가 'SALESMAN'인 직원들의 직원번호(EMPNO), 이름(ENAME), 급여(SAL)를 조회
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE JOB = 'SALESMAN';

-- 부서번호가 10번이 아닌 직원들의 모든 정보를 조회
SELECT *
FROM EMP
WHERE DEPTNO != 10;
-- 직무(JOB)가 'SALESMAN'이 아닌 직원들의 직원번호(EMPNO), 이름(ENAME), 급여(SAL)를 조회
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE JOB != 'SALESMAN';

SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE NOT JOB = 'SALESMAN';

-- 급여(SAL)가 1500 이상,  2500 이하인 직원들의 모든 정보를 조회
SELECT *
FROM EMP
WHERE SAL >= 1500 AND SAL <= 2500;

SELECT *
FROM EMP
WHERE SAL BETWEEN 1500 AND 2500;

/* 조건 문자형 */
-- 직무(JOB)가 'SALESMAN'인 직원들의 직원번호(EMPNO), 이름(ENAME), 급여(SAL)를 조회
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE JOB = 'SALESMAN';
/* 
와일드 문자 : LIKE 키워드와 함께 사용
1. _ : 어떤 값이든 한글자를 대체 해주는 문자
2. % : 길이에 상관없이 대체 해주는 문자
*/
--  직무(JOB)가 'SA  MAN'인 직원들의 모든 정보 조회
SELECT *
FROM EMP
WHERE JOB LIKE 'SA___MAN';
SELECT *
FROM EMP
WHERE JOB LIKE 'SA%MAN';
-- 직원이름(ENAME)에 네번째 글자가 'K'인 직원들의 모든 정보 조회
SELECT *
FROM EMP
WHERE ENAME LIKE '___K%';
-- 직원이름이 4글자인 직원 조회
SELECT *
FROM EMP
WHERE ENAME LIKE '____';

/* 조건 - NULL( NULL비교는 IS) */
-- COMM을 받는 않는 직원들의 모든 정보를 조회(COMM 컬럼의 값이 NULL인)
SELECT *
FROM EMP
WHERE COMM IS NULL;
-- COMM을 받는 직원들의 모든 정보를 조회(COMM 컬럼의 값이 NULL이 아닌)
SELECT *
FROM EMP
WHERE COMM IS NOT NULL;

/* 조건 - 날짜형 */
-- 입사일(HIREDATE)이 1981년 9월 8일인 직원의 모든 정보를 조회
SELECT *
FROM EMP
WHERE HIREDATE = '1981-09-08';
UPDATE EMP
SET HIREDATE = '1981-09-08 19:37'
WHERE EMPNO = 7844;
-- 입사일(HIREDATE)이 1981년 9월 8일인 직원의 모든 정보를 조회 -- 1981-09-08 19:37
/* TO_DATE : 문자를 날짜로
   TO_CHAR : 날짜를 문자로 */
SELECT *
FROM EMP
WHERE TO_CHAR(HIREDATE, 'YYYY-MM-DD') = '1981-09-08';
-- 입사일(HIREDATE) 1981년 9월 이후인 직원들의 모든 정보를 조회
SELECT *
FROM EMP
WHERE TO_CHAR(HIREDATE, 'YYYY-MM') >= '1981-09';

SELECT *
FROM EMP
WHERE HIREDATE >= TO_CHAR('1981-09', 'YYYY-MM');

-- 입사일(HIREDATE) 12월인 직원들의 모든 정보를 조회
SELECT *
FROM EMP
WHERE TO_CHAR(HIREDATE, 'MM') = '12';

SELECT SYSDATE, SYSDATE - 1, SYSDATE+1, SYSDATE - 1/24 -- 1=하루 1/24=1시간 
FROM DUAL;

/* 별칭(ALIAS) */
--컬럼몀 AS 별칭(첫번째 방법이 좋다)
SELECT EMPNO AS 직원번호, ENAME AS 직원이름, TO_CHAR(HIREDATE, 'YYYY-MM') AS HIREDATE
FROM EMP;
-- 컬럼명 AS "별칭"
SELECT EMPNOAS AS "직원번호", ENAME AS "직원이름", TO_CHAR(HIREDATE, 'YYYY-MM') AS "HIREDATE"
FROM EMP;
-- 컬럼명 별칭
SELECT EMPNO 직원번호, ENAME 직원이름, TO_CHAR(HIREDATE, 'YYYY-MM') HIREDATE
FROM EMP;
-- 컬럼명 "별칭"
SELECT EMPNO "직원번호", ENAME "직원이름", TO_CHAR(HIREDATE, 'YYYY-MM') "HIREDATE"
FROM EMP;

/* 문자 결합 */
SELECT ENAME, SAL||' 달러' -- 800 달러
FROM EMP;

SELECT EMPNO||ENAME -- 7369SMITH
FROM EMP;

SELECT EMPNO||','||ENAME -- 7369,SMITH
FROM EMP;

SELECT TO_CHAR(HIREDATE, 'YYYY')||'년' -- 1980년
FROM EMP;

SELECT TO_CHAR(HIREDATE, 'YYYY')||'년'||TO_CHAR(HIREDATE, 'MM')||'월'||TO_CHAR(HIREDATE, 'DD')||'일' AS 입사일
FROM EMP; -- 1980년12월17일

SELECT ENAME AS 직원이름, SAL AS 월급, SAL * 12 AS 연봉
FROM EMP;


-----day06

-- WHERE - AND, OR
-- 입사년도가 1981년 이고 부서번호가 30번인 직원들의 이름과, 직책을 조회
SELECT ENAME, JOB
FROM EMP
WHERE TO_CHAR(HIREDATE, 'YYYY') = '1981' AND DEPTNO = 30;  -- 6명
-- 입사년도가 1981년 이거나 부서번호가 20번인 직원들의 이름과, 직책을 조회
SELECT ENAME, JOB
FROM EMP
WHERE TO_CHAR(HIREDATE, 'YYYY') = '1981' OR DEPTNO = 20; -- 11명
-- 직책(JOB)이 'MANAGER' 이거나 'SALESMAN'인 직원들의 모든 정보를 조회
SELECT *
FROM EMP
WHERE  JOB = 'MANAGER' OR JOB = 'SALESMAN';
-- 직책(JOB)이 'MANAGER' 이거나 'SALESMAN' 'ANALYST'인 직원들의 모든 정보를 조회
SELECT *
FROM EMP
WHERE  JOB IN('MANAGER','SALESMAN', 'ANALYST'); -- JOB안에 MANAGER, SALESMAN, ANALYST가 있으면

-- 직책(JOB)이 'MANAGER' 이거나 'SALESMAN' 인 직원들 중에서 COMM을 받지 않는 직원의 정보 조회
SELECT *
FROM EMP
WHERE JOB = 'SALESMAN' OR JOB = 'MANAGER' AND COMM IS NULL; -- OR 기준으로 왼쪽에 있는 것과 오른쪽 전체와 비교
 --   JOB = 'SALESMAN' OR ( JOB = 'MANAGER' AND COMM IS NULL; )

SELECT *
FROM EMP
WHERE JOB = 'MANAGER' OR JOB = 'SALESMAN' AND COMM IS NULL; -- AND면 ()로 구분 안해도됨 OR이면 ()구분
 --   JOB = 'MANAGER' OR ( JOB = 'SALESMAN' AND COMM IS NULL; )
 
SELECT *
FROM EMP
WHERE (JOB = 'MANAGER' OR JOB = 'SALESMAN') AND COMM IS NULL;

SELECT *
FROM EMP
WHERE JOB IN('MANAGER', 'SALESMAN') AND COMM IS NULL;

-- 테이블안에 데이터는 대소문자 구분 해야됨
select *
from emp
where job = 'SALESMAN';
-- 대문자 변환 : UPPER, 소문자 LOWER
select *
from emp
where job = 'salesman';
-- UPPER('문자데이터') >> 대문자로 변환
select *
from emp
where job = UPPER('salesman');
-- LOWER('문자데이터') >> 소문자로 변환
select *
from emp
where LOWER(job) = 'salesman';
-- LENGTH('문자') >> 문장의 길이
SELECT ENAME, LENGTH(ENAME)
FROM EMP;

/* 그룹 함수 
   SUM, COUNT, MAX, MIN, AVG
*/
-- SUM() 총합을 구하는 함수
-- 직원들의 SAL의 총합
SELECT SUM(SAL)
FROM EMP;
-- COUNT() 조회되는 레코드이 개수
SELECT COUNT(ENAME)
FROM EMP;
-- MAX() 해당 컬럼의 최대값 구하는 함수
SELECT MAX(SAL)
FROM EMP;
-- MIN() 해당 컬럼의 촤소값을 구하는 함수
SELECT MIN(SAL)
FROM EMP;
-- AVG() 해당 컬럼의 평균값을 구하는 함수
SELECT AVG(SAL)
FROM EMP;

-- 모든 직원의 이름과, 급여를 조회
SELECT ENAME, SAL
FROM EMP;

-- 부서번호 급여 조회
SELECT DEPTNO, SAL
FROM EMP;

-- 부서별 급여의 총합
SELECT DEPTNO, SUM(SAL)
FROM EMP
GROUP BY DEPTNO;

-- 직책별 급여의 총합
SELECT JOB, SUM(SAL)
FROM EMP
GROUP BY JOB;

-- 부서별 인원수
SELECT DEPTNO, COUNT(*)
FROM EMP
GROUP BY DEPTNO;

-- 20번 부서의 인원수 조회
SELECT DEPTNO, COUNT(*)
FROM EMP
WHERE DEPTNO = 20 -- WHERE 테이블 전체를 대상으로
GROUP BY DEPTNO;

SELECT DEPTNO, COUNT(*)
FROM EMP
GROUP BY DEPTNO
HAVING DEPTNO = 20; -- HAVING 나눠진 그룹을 대상으로 조건

/*
SELECT 컬럼명...
FROM 테이블명
WHERE 조건(필요한 레코드만 선별)
GROUP BY 그룹을 나눌 컬럼
HAVING 그룹 조건(그룹을 만들고 써야됨)
ORDER BY 정령기준
*/
-- 부서별로 그룹을 구성하고, 인원이 4명 이상인 부서 조회
SELECT DEPTNO, COUNT(*)
FROM EMP
GROUP BY DEPTNO
HAVING COUNT(*) >= 4;
-- 직책(JOB)별 평균 급여(SAL)가 3000이상인 직책(JOB)과 평균 급여(AVG), 인원수(COUNT) 조회
SELECT JOB, AVG(SAL), COUNT(*)
FROM EMP
GROUP BY JOB
HAVING AVG(SAL) >= 3000;

-- 직책(JOB)별 평균 급여(SAL)가 3000이상인 [직책(JOB)과 평균 급여(AVG), 인원수(COUNT) 조회]
-- 단 부서가 10, 30인 직원을 대상으로
SELECT JOB, AVG(SAL), COUNT(*)
FROM EMP
WHERE DEPTNO IN(10,30)
GROUP BY JOB
HAVING AVG(SAL) >= 3000;

SELECT JOB, AVG(SAL), COUNT(*)
FROM EMP
GROUP BY JOB, DEPTNO
HAVING AVG(SAL) >= 3000 AND DEPTNO IN(10,30);

-- 인원수가 5명이 이상인 부서의 부서번호, 인원수, 평균연봉 조회
SELECT COUNT(*), DEPTNO, AVG(SAL*12)
FROM EMP
GROUP BY DEPTNO
HAVING COUNT(*) >= 5;

SELECT ENAME, JOB, (SAL + COMM), SAL, COMM -- 800 + NULL = NULL
FROM EMP;
-- NVL(컬럼명, 대체할 값)- NULL값을 다른 값으로 대체
SELECT ENAME, JOB, (SAL + COMM), SAL, COMM, NVL(COMM, 0), (SAL+ NVL(COMM,0)) -- 800 + 0 = 800(NULL값을 0으로 대체)
FROM EMP;

/* ORDER BY : 정렬기준(제일 마지막 구문의 사용) - 오름차순(ASC)-기본값, 내림차순(DESC) */
SELECT *
FROM EMP
ORDER BY ENAME; -- 직원이름 기준 오름차순 정렬 (기본값)

SELECT *
FROM EMP
ORDER BY ENAME DESC; -- 직원이름 기준 내림차순 정렬 (DESC 필수)

SELECT *
FROM EMP
ORDER BY JOB DESC, SAL; -- 직책 기준 내림차순 정렬 (DESC 필수)

/*
SELECT
FROM
WHERE
GROUP BY
HAVING
ORDER BY
*/
-- 이름이 WARD인 직원과 같은 부서에서 근무하는 직원들의 정보 조회
-- 1. 이름이 WARD인 직원의 부서번호 조회 -- DEPTNO :: 30
SELECT DEPTNO
FROM EMP
WHERE ENAME = 'WARD'; -- 30(결과값)
-- 2. 조회된 부서번호를 바탕으로 해당 부서의 직원정보를 조회
-- 서브 쿼리 : 쿼리문 안에 또 다른 퀴리문이 들어가는 것
SELECT *
FROM EMP
WHERE DEPTNO = (SELECT DEPTNO
                FROM EMP
                WHERE ENAME = 'WARD');


-----day07

/* 서브쿼리(한 타입에 데이터가 여러개일 경우 =대신 IN을 사용) */
/* WHERE 절 SELECT문 사용 
   WHERE 절: 특정한 레코드를 선별하기위한 조건
*/
-- 부서번호가 10인 직원들의 정보를 조회
SELECT *
FROM EMP
WHERE DEPTNO = 10;
-- 직원이름이 KING인 직원과 같은 부서에서 근무하는 직원들의 정보를 조회
-- 1. 이름이 KING인 직원의 부서번호 조회
SELECT DEPTNO
FROM EMP
WHERE ENAME = 'KING'; -- 10
-- 2. 10번 부서에서 근무하는 직원들의 정보를 조회
SELECT *
FROM EMP
WHERE DEPTNO = (SELECT DEPTNO
                FROM EMP
                WHERE ENAME = 'KING');

SELECT *
FROM EMP
WHERE DEPTNO IN (SELECT DEPTNO
                FROM EMP
                WHERE JOB = 'MANAGER');

-- 평균 급여보다 많으 급여를 받는 직원들의 정보를 조회
-- 1.평균 급여 조회
SELECT AVG(SAL)
FROM EMP; -- 2077.084
-- 2.조회된 평균 급여와 직원의 급여를 비교(급여(SAL)가 2077보다 큰 직원들)
SELECT *
FROM EMP
WHERE SAL >= (SELECT AVG(SAL)
              FROM EMP);
              
-- 'JONES'보다 급여를 많이 받는 직원들의 정보를 조회
-- 1.'JONES'의 SAL 조회
SELECT SAL
FROM EMP
WHERE ENAME = 'JONES';

-- 2.조회된'JONES'의 SAL보다 많은 급여를 받는 직원들의 정보를 조회
SELECT *
FROM EMP
WHERE SAL >= (SELECT SAL
              FROM EMP
              WHERE ENAME = 'JONES');

/* 'SALESMAN'이 근무하지 않는 부서의 부서번호와 인원수를 조회 */
SELECT DEPTNO
FROM EMP
WHERE JOB = 'SALESMAN';

SELECT DEPTNO, COUNT(*)
FROM EMP
WHERE DEPTNO NOT IN (SELECT DEPTNO
                     FROM EMP
                     WHERE JOB = 'SALESMAN')
GROUP BY DEPTNO;

-- 'JAMES'와 같은 달에 입사한 직원의 이름과 직무 급여를 조회
--1.'JAMEW'가 입사한달(MONTH) 조회
SELECT TO_CHAR(HIREDATE, 'MM')
FROM EMP
WHERE ENAME = 'JAMES'; -- 12
--2.12월에 입사한 직원의 이름 직무 급여 
SELECT ENAME, JOB, SAL
FROM EMP
WHERE TO_CHAR(HIREDATE, 'MM') = (SELECT TO_CHAR(HIREDATE, 'MM')
                                 FROM EMP
                                 WHERE ENAME = 'JAMES');

-- 부서별 평균 급여가 'MANAGER'의 평균 급여 보다 높은 부서의 번호와 평균급여를 조회
--1.'MANAGER'의 평균 급여
SELECT AVG(SAL)
FROM EMP
WHERE JOB = 'MANAGER';
--2.부서별 평균급여 조회
SELECT DEPTNO, AVG(SAL)
FROM EMP
GROUP BY DEPTNO
HAVING AVG(SAL) > (SELECT AVG(SAL)
                   FROM EMP
                   WHERE JOB = 'MANAGER');

/* JOIN : 두 개 이상의 테이블을 연결하여 하난의 테이블터럼 만들어 사용
   INNER JOIN, OUTER JOIN
*/
SELECT *
FROM EMP, DEPT; -- 48개의 레코드(기준이 되는 테이블보다 레코드수가 더 많이 나오면 조건이 잘못됬거나 없는것)
SELECT * FROM EMP;  -- 12개의 레코드
SELECT * FROM DEPT; -- 4개의 레코드
-- WHERE절에 조인을 위한 조건과 레코드를 선별하기 위한 조건을 같이 쓰는 방법
SELECT *
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO AND EMP.ENAME = 'SMITH';

-- FROM절에 조인을 위한 조건을 쓰는 방법
SELECT *
FROM EMP INNER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO
WHERE EMP.ENAME = 'SMITH';
-- 테이블명 별칭(FROM부터 나오는 테아블명은 별칭으로 써야함)-SQL을 프로그램이 읽을때 FROM부터 읽음
SELECT *
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;
SELECT *
FROM EMP E INNER JOIN DEPT D ON E.DEPTNO = D.DEPTNO;

SELECT ENAME, DNAME, D.DEPTNO, E.DEPTNO
FROM EMP E INNER JOIN DEPT D ON E.DEPTNO = D.DEPTNO;

-- 'SMITH'가 근무하는 부서의 이름, 지역 조회
-- 조인
SELECT DEPT.DEPTNO, DEPT.LOC
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO AND ENAME = 'SMITH';

SELECT DEPT.DEPTNO, DEPT.LOC
FROM EMP INNER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO
WHERE EMP.ENAME = 'SMITH';
-- 서브쿼리문
SELECT DEPTNO, LOC
FROM DEPT
WHERE DEPTNO = (SELECT DEPTNO FROM EMP WHERE ENAME = 'SMITH');

-- 'NEW YORK'에서 근무하는 직원의 부서이름, 직원이름, 직책 조회
SELECT DEPT.DNAME, EMP.ENAME, EMP.JOB
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO AND DEPT.LOC = 'NEW YORK';

SELECT DEPT.DNAME, EMP.ENAME, EMP.JOB
FROM EMP INNER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO
WHERE DEPT.LOC = 'NEW YORK';

-- 'SMITH' 직원의 상급자(MGR)의 이름 조회
SELECT ENAME 
FROM EMP
WHERE EMPNO = (SELECT MGR FROM EMP WHERE ENAME='SMITH');

SELECT E1.ENAME ||'의 MGR은'||E2.ENAME ||'입니다'
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO; -- EMP.E1-7902 = EMP.E2-7902

/*
|| 부서이름 ||  지역  || 직원수 ||
  RESEARCH   DALLAS     3
  SALES      CHICAGO    6
*/
-- 부서별 직원수 조회
SELECT DEPTNO, COUNT(*)
FROM EMP
GROUP BY DEPTNO;
-- SELECT문으로 나온 결과값을 하나의 테이블로 활용
SELECT D.DNAME, D.LOC, COUNT_E.EMPCOUNT
FROM DEPT D, (SELECT DEPTNO, COUNT(*) AS EMPCOUNT FROM EMP GROUP BY DEPTNO) COUNT_E
WHERE D.DEPTNO = COUNT_E.DEPTNO;


-----day08

--부서별 평균 급여 조회 (부서이름, 평균급여)
SELECT D.DNAME, AVG(E.SAL)
FROM EMP E INNER JOIN DEPT D ON E.DEPTNO = D.DEPTNO
GROUP BY D.DNAME;

SELECT DEPTNO, AVG(SAL)
FROM EMP
GROUP BY DEPTNO;

-- 직원이름, 급여, 부서별 평균
-- SMITH   800    2258
-- ALLEN   1600   1566

--1. EMP 부서별 평균 급여 조회
SELECT DEPTNO, AVG(SAL)
FROM EMP
GROUP BY DEPTNO;
--2. EMP테이블과 1번의 SELECT문 결과를 조인
SELECT E1.ENAME, E1.SAL, E2.DEPTNO, E2.DEPTAVG
FROM EMP E1 INNER JOIN (SELECT DEPTNO, AVG(SAL) AS DEPTAVG FROM EMP GROUP BY DEPTNO) E2 ON E1.DEPTNO = E2.DEPTNO;
--WHERE E1.ENAME = 'SMITH';

--3. DEPTNO 대신 ENAME(부서이름)으로 출력
SELECT E1.ENAME, E1.SAL, E2.DEPTAVG
FROM EMP E1 INNER JOIN (SELECT DEPTNO, AVG(SAL) AS DEPTAVG FROM EMP GROUP BY DEPTNO) E2 
                        ON E1.DEPTNO = E2.DEPTNO INNER JOIN DEPT D ON E1.DEPTNO = D.DEPTNO;
                        
-- 직원이름(ENAME), 직무(JOB), 직무별 인원수
--1. 직무별 인원수 조회
SELECT JOB, COUNT(*)
FROM EMP
GROUP BY JOB;
--2. EMP테이블 1번 결과를 조인
SELECT E1.ENAME, E1.JOB, E2.JCOUNT
FROM EMP E1, (SELECT JOB, COUNT(*) AS JCOUNT FROM EMP GROUP BY JOB) E2
WHERE E1.JOB = E2.JOB;

-- ROWNUM
SELECT ROWNUM, EMP.*
FROM EMP;

--1.
SELECT ROWNUM AS SALRANK, EMP.*
FROM EMP
ORDER BY SAL DESC;

--2.
SELECT ROWNUM AS SALRANK, EMP.*
FROM (SELECT * FROM EMP ORDER BY SAL DESC) EMP;

--3.
SELECT *
FROM (SELECT ROWNUM AS SALRANK, EMP.* FROM (SELECT * FROM EMP ORDER BY SAL DESC) EMP)
WHERE ENAME = 'SMITH'; -- SMITH의 SAL순위

-- VIEW(가상테이블)
-- CREATE VIEW
CREATE OR REPLACE VIEW SALRANK_EMP
AS ( SELECT ROWNUM AS SALRANK, EMP.* 
     FROM (SELECT * FROM EMP ORDER BY SAL DESC) EMP ); -- 3.

SELECT *
FROM SALRANK_EMP
WHERE ENAME = 'SMITH';
;

/*
UPDATE 테이블명
SET 컬럼명 = 수정할 값
WHERE 데이터를 수정할 레코드
*/
--JAMES'의 급여를 1000으로 수정(WHERE절로 바꿀값 선별-안하면 모든값 바뀜)
UPDATE EMP
SET SAL = 1000
WHERE ENAME = 'JAMES';

--JAMES'의 급여를 100 증가
UPDATE EMP
SET SAL = SAL + 100
WHERE ENAME = 'JAMES';
SELECT * FROM EMP;

-- MGR 이 'BLAKE'인 직원들의 급여를 200증가
UPDATE EMP
SET SAL = SAL + 200
WHERE MGR = (SELECT EMPNO FROM EMP WHERE ENAME = 'BLAKE');

SELECT *
FROM SALRANK_EMP;

-- DELETE
/*
DELETE FROM 테이블명
WHERE 삭제할 레코드를 선별
*/
-- 급여를 가장 적게 받는 직원이 근무하는 부서의 직원들을 모두 삭제
--1. 급여의 최소값(MIN(SAL)) 조회 : 800
SELECT MIN(SAL)
FROM EMP;
--2. 급여가 MIN(SAL)인 직원의 부서번호 조회 : 20
SELECT DEPTNO
FROM EMP
WHERE SAL = (SELECT MIN(SAL) FROM EMP);

--3. 해당 부서의 직원정보 삭제
DELETE FROM EMP
WHERE DEPTNO = (SELECT DEPTNO
                FROM EMP
                WHERE SAL = (SELECT MIN(SAL) FROM EMP));
SELECT * FROM EMP;
ROLLBACK;

-- 'ALLEN'의 부서번호를 50번으로 수정
UPDATE EMP
SET DEPTNO = 50
WHERE ENAME = 'ALLEN'; 
-- ORA-02291: 무결성 제약조건(JGH_DBA.FK_DEPTNO)이 위배되었습니다- 부모 키가 없습니다
SELECT * FROM DEPT; -- EMP의 DEPTNO은 DEPT에 DEOTNO울 참조하고 있어서 오류(DEOTNO = 10,20,30,40)

DELETE FROM DEPT
WHERE DEPTNO = 30;
-- ORA-02292: 무결성 제약조건(JGH_DBA.FK_DEPTNO)이 위배되었습니다- 자식 레코드가 발견되었습니다


-----day09

/* 쇼핑몰(회원, 상품, 주문내역) */
/* 회원정보 테아블(MEMBERS) */
SELECT * FROM USER_TABLES; -- 현재 접속중인 계정에 있는 테이블
SELECT * FROM USER_CONSTRAINTS; -- 현재 접속중인 계정에 있는 제약조건

DROP TABLE LOGINCHECK;
DROP TABLE MEMBERS;
CREATE TABLE MEMBERS(
    MID NVARCHAR2(10),      -- 회원 아이디(PRIMARY KEY)
    MPW NVARCHAR2(20),      -- 회원 비밀번호(NOT NULL)
    MNAME NVARCHAR2(5),     -- 회원 이름(NOT NULL)
    MPHONE NVARCHAR2(13),   -- 회원 전화번호
    MBIRTH DATE             -- 회원 생년월일
);
-- 제약 조건 부여
ALTER TABLE MEMBERS
ADD CONSTRAINT PK_MEM_MID PRIMARY KEY (MID)
MODIFY MPW NOT NULL
MODIFY MNAME NOT NULL;
DESC MEMBERS;

/* 상품정보 테이블(GOODS) */
/* 상품코드, 상품이름, 상품가격, 상품종류, 상품재고 */
DROP TABLE GOODS;
CREATE TABLE GOODS(
    GCODE NVARCHAR2(5),     -- 상품코드(PRIMARY KEY)
    GNAME NVARCHAR2(30),    -- 상품이름(NOT NULL)
    GPRICE NUMBER,          -- 상품가격(DEFAULT 1000)
    GTYPE NVARCHAR2(10),    -- 상품종류
    GSTOCK NUMBER           -- 상품재고
);
ALTER TABLE GOODS
ADD CONSTRAINT PK_GOO_GCODE PRIMARY KEY (GCODE)
MODIFY GNAME NOT NULL
MODIFY GPRICE DEFAULT 1000;
DESC GOODS;

/* CHECK 제약
1. GCODE 컬럼의 글자수 제약(무조건 5글자)
2. GCODE 컬럼의 첫글자는 'G'로 시작하도록 제약
3. GSTOCK 컬럼은 0미만의 값은 입력할 수 없도록 제약
*/
SELECT LENGTH('ABCD')FROM DUAL;
SELECT SUBSTR('ABCDEFGH', 1.1) FROM DUAL;

ALTER TABLE GOODS
ADD CONSTRAINT CK_GCODE_LTH CHECK(LENGTH(GCODE) = 5);
ALTER TABLE GOODS
ADD CONSTRAINT CK_GCODE_FIRST CHECK(SUBSTR(GCODE, 1,1) = 'G');
ALTER TABLE GOODS
ADD CONSTRAINT CK_GSTOCK CHECK(GSTOCK >= 0);
COMMIT;

/* 주문내역(ORDERS) 
    주문코드(PK), 회원아이디(FK-MEMBER(MID)), 상품코드(FK-GOODS(GCODE)), 주문수량, 주문일시
*/
CREATE TABLE ORDERS(
    ODCODE NVARCHAR2(5),    -- 주문코드(PRIMARY KEY)
    ODMID NVARCHAR2(10),    -- 주문자아이디(FOREIGN KEY-MEMBERS(MID))
    ODGCODE NVARCHAR2(5),   -- 주문상품(FOREIGN KEY-GOODS(GCODE))
    ODQTY NUMBER,           -- 주문수량
    ODDATE DATE             -- 주문일시
);
ALTER TABLE ORDERS
ADD CONSTRAINT PK_ORDERS PRIMARY KEY(ODCODE);
ALTER TABLE ORDERS
ADD CONSTRAINT FK_ORDERS_MID FOREIGN KEY(ODMID) REFERENCES MEMBERS(MID);
ALTER TABLE ORDERS
ADD CONSTRAINT FK_ORDERS_GCODE FOREIGN KEY(ODGCODE) REFERENCES GOODS(GCODE);

INSERT INTO MEMBERS(MID, MPW, MNAME, MPHONE, MBIRTH)
VALUES ('JGH','1234','전관호','010-4904-3741','2001-11-09');
INSERT INTO GOODS(GCODE, GNAME, GPRICE, GTYPE, GSTOCK)
VALUES ('G3000','아메리카노', 3000, '식품', 30);
COMMIT;
SELECT * FROM MEMBERS;
SELECT * FROM GOODS;

/* 쇼핑몰
1. 회원기능 - 회원가입, 로그인기능, 내정보확인, 
            내주문내역
2. 상품기능 - 전체상품목록, 종류별상품목록
             상품주문기능 */
/* [회원가입기능]
CONSOLE(SCANNER) >> 가입할 아이디 ~ 생년월일 입력 */
INSERT INTO MEMBERS(MID, MPW, MNAME, MPHONE, MBIRTH)
VALUES('입력한아이디', '입력한비밀번호', '입력한이름', '입력한전화번호', TO DATE('입력한생년월일','YYYY-MM-DD')); -- 회원가입
/* [로그인기능] 
CONSOLE(SCANNER) >> 로그인할 아이디, 로그인할 비밀번호 >> 입력
*/
SELECT *
FROM MEMBERS
WHERE MID = '로그인할아이디' AND MPW = '로그인할비밀번호';
-- 레코드가 조회되면 >> 로그인 처리
-- 래코드가 조회되지 않으면 >> 아이디/비밀번호가 일치하지 않습니다.

/* [내정보확인기능] - 로그인 중인 상태 */
SELECT *
FROM MEMBERS
WHERE MID = '로그인중인아이디';

/* [내주문목록]기능 - 로그인 중인 상태 
상품이름(GOODS-GNAME), 주문수량(ORDERS-ODQTY), 주문금액(GPRICE * ODQTY), 주문일(ORDER - ODDATE)
조건 - ODMID = '로그인 중인 아이디'
*/


-----day10

/* [전체상품목록] 기능 
상품이름, 상품가격, 재고, 종류
*/
SELECT *
FROM GOODS -- 전체상품목록
WHERE GSTOCK > 0; -- 판매가 가능한 상품목록(재고가 0이 아닌것) 
--ORDER BY GSTOCK DESC;
/* [종류별상품목록] 선택하 종류 '식품' 기능 */
SELECT *
FROM GOODS
WHERE GTYPE = '식품' AND GSTOCK > 0;

/* [상품주문]기능 - 바나나우유 상품 구매, 5개를 구매 */
--1. ORDERS 테이블에 INSERT
INSERT INTO ORDERS(ODCODE, ODMID, ODGCODE, ODQTY, ODDATE)
VALUES ('O0001','JGH', 'G0115', 5, SYSDATE); --1 행 이(가) 삽입되었습니다.
--2. GOODS 테이블에 UPPDATE
UPDATE GOODS
SET GSTOCK = GSTOCK - 5
WHERE GCODE = 'G0115'; --1 행 이(가) 업데이트되었습니다.
COMMIT;
SELECT * FROM MEMBERS;
SELECT * FROM GOODS;
SELECT * FROM ORDERS;

/* [상품주문]기능 - G3000 상품 구매, 1개를 구매 */
--1. ORDERS 테이블에 INSERT
INSERT INTO ORDERS(ODCODE, ODMID, ODGCODE, ODQTY, ODDATE)
VALUES ('O0002','JGH', 'G3000', 1, SYSDATE);
--2. GOODS 테이블에 UPPDATE
UPDATE GOODS
SET GSTOCK = GSTOCK - 1
WHERE GCODE = 'G3000';

/* [상품주문]기능 - G1357 상품 구매, 3개를 구매 */
--1. ORDERS 테이블에 INSERT
INSERT INTO ORDERS(ODCODE, ODMID, ODGCODE, ODQTY, ODDATE)
VALUES ('O0003','YKD', 'G1357', 3, SYSDATE);
--2. GOODS 테이블에 UPPDATE
UPDATE GOODS
SET GSTOCK = GSTOCK - 3
WHERE GCODE = 'G1357';

/* [상품주문]기능 - G1234 상품 구매, 1개를 구매 */
--1. ORDERS 테이블에 INSERT
INSERT INTO ORDERS(ODCODE, ODMID, ODGCODE, ODQTY, ODDATE)
VALUES ('O0004','GDH', 'G1234', 1, SYSDATE);
--2. GOODS 테이블에 UPPDATE
UPDATE GOODS
SET GSTOCK = GSTOCK - 1
WHERE GCODE = 'G1234';

/* [상품주문]기능 - G2468 상품 구매, 10개를 구매 */
--1. ORDERS 테이블에 INSERT
INSERT INTO ORDERS(ODCODE, ODMID, ODGCODE, ODQTY, ODDATE)
VALUES ('O0005','PYJ', 'G2468', 10, SYSDATE);
--2. GOODS 테이블에 UPPDATE
UPDATE GOODS
SET GSTOCK = GSTOCK - 10
WHERE GCODE = 'G2468';

/* [주문내역조회] 기능 
[주문자이름][상품이름][상품가격][주문수량][총주문금액][주문일시]
*/
/*
SELECT
FROM 테이블A, 테이블B, 테이블C
WHERE 조인조건
*/
SELECT MNAME, GNAME, GPRICE, ODQTY, GPRICE*ODQTY, ODDATE
FROM MEMBERS M, GOODS G, ORDERS O
WHERE M.MID = O.ODMID AND G.GCODE = O.ODGCODE AND O.ODMID = 'JGH';

/*
SELECT
FROM 테이블A INNER JOIN 테이블B IN 조인조건 INNER JOIN 테이블C ON 조인조건
*/
SELECT MNAME, GNAME, GPRICE, ODQTY, GPRICE*ODQTY, ODDATE
FROM MEMBERS M INNER JOIN ORDERS O ON M.MID = O.ODMID INNER JOIN GOODS G ON G.GCODE = O.ODGCODE
WHERE O.ODMID = 'JGH';

/* [종류별상품목록] 선택한 종류 '식품' 기능 - 가격이 낮은 순 */
SELECT *
FROM GOODS
WHERE GTYPE = '식품' AND GSTOCK > 0
ORDER BY GPRICE;
-- 주문금액이 가장 많은 회원 순으로 정렬  - 회원아이디, 총구매액수
SELECT O.ODMID, SUM(O.ODQTY*G.GPRICE) AS TOTALPRICE
FROM ORDERS O, GOODS G
WHERE O.ODGCODE = G.GCODE
GROUP BY O.ODMID
ORDER BY TOTALPRICE DESC;

-- 주문 수가 가장 많은 회원 순으로 정렬 - 회원아이디, 총주문수
SELECT ODMID, COUNT(*) AS TOTALORDERS
FROM ORDERS
GROUP BY ODMID
ORDER BY TOTALORDERS DESC;

SELECT *
FROM MEMBERS M,(SELECT ODMID, COUNT(*) AS TOTALORDERS
                FROM ORDERS
                GROUP BY ODMID
                ORDER BY TOTALORDERS DESC)OD
WHERE M.MID = OD.ODMID;

SELECT *
FROM MEMBERS M INNER JOIN (SELECT ODMID, COUNT(*) AS TOTALORDERS
                           FROM ORDERS
                           GROUP BY ODMID)OD
ON M.MID = OD.ODMID;

/* OUTER JOIN */
SELECT *
FROM MEMBERS M INNER JOIN ORDERS OD ON M.MID = OD.ODMID;

SELECT *
FROM MEMBERS M LEFT OUTER JOIN ORDERS OD ON M.MID = OD.ODMID; -- 왼쪽기준(MEMBERS)-24개 레코드

SELECT *
FROM MEMBERS M RIGHT OUTER JOIN ORDERS OD ON M.MID = OD.ODMID; -- 오른쪽기준(ORDERS)-5개 레코드

/* 주문 수가 가장 많은 회원 순으로 정렬(주문한 회원만) */
SELECT *
FROM MEMBERS M INNER JOIN (SELECT ODMID, COUNT(*) AS TOTALORDERS
                           FROM ORDERS
                           GROUP BY ODMID)OD ON M.MID = OD.ODMID;
/* 주문 수가 가장 많은 회원 순으로 정렬(주문하지 않은 회원까지) */
SELECT *
FROM MEMBERS M LEFT OUTER JOIN (SELECT ODMID, COUNT(*) AS TOTALORDERS
                           FROM ORDERS
                           GROUP BY ODMID)OD ON M.MID = OD.ODMID
ORDER BY OD. TOTALORDERS;

-- 판매량이 많은 순(인기제품)
--1. ORDERS
SELECT ODGCODE, SUM(ODQTY) AS TOTALQTY
FROM ORDERS
GROUP BY ODGCODE;
--2
SELECT *
FROM GOODS G INNER JOIN (SELECT ODGCODE, SUM(ODQTY) AS TOTALQTY
                         FROM ORDERS
                         GROUP BY ODGCODE) OD
            ON G.GCODE = OD.ODGCODE
ORDER BY OD.TOTALQTY; -- 판매 된적이 있는 상품만

SELECT G.*, NVL(OD.TOTALQTY,0) -- NULL값을 0으로 대체
FROM GOODS G LEFT OUTER JOIN (SELECT ODGCODE, SUM(ODQTY) AS TOTALQTY
                         FROM ORDERS
                         GROUP BY ODGCODE) OD
            ON G.GCODE = OD.ODGCODE
ORDER BY NVL(OD.TOTALQTY,0) DESC; -- 판매 된적이 없는 상품까지



-----day11
/* INNER JOIN  */
SELECT *
FROM ORDERS OD INNER JOIN MEMBERS M ON M.MID = OD.ODMID;

SELECT *
FROM MEMBERS M INNER JOIN ORDERS OD ON M.MID = OD.ODMID;

/* OUTER JOIN, ORDERS, MEMBERS */

SELECT *
FROM ORDERS OD LEFT OUTER JOIN MEMBERS M ON M.MID = OD.ODMID;

SELECT *
FROM MEMBERS M LEFT OUTER JOIN ORDERS OD ON M.MID = OD.ODMID;

SELECT *
FROM ORDERS OD RIGHT OUTER JOIN MEMBERS M ON M.MID = OD.ODMID;

SELECT *
FROM MEMBERS M RIGHT OUTER JOIN ORDERS OD ON M.MID = OD.ODMID;

SELECT *
FROM ORDERS OD FULL OUTER JOIN MEMBERS M ON M.MID = OD.ODMID;

SELECT *
FROM MEMBERS M FULL OUTER JOIN ORDERS OD ON M.MID = OD.ODMID;

/* 판매량이 많은순으로 정렬해서 상품 목록을 보여주세요 */
--1. 어떤 제품이 얼만큼 판매가 되었는지 조회 - ORDERS
SELECT ODGCODE, SUM(ODQTY)
FROM ORDERS
GROUP BY ODGCODE;

--2. 상품릏 판매량 수능로 정렬
SELECT *
FROM GOODS G INNER JOIN (SELECT ODGCODE, SUM(ODQTY)
                         FROM ORDERS
                         GROUP BY ODGCODE) OD
             ON G.GCODE = OD.ODGCODE;

SELECT *
FROM GOODS G LEFT OUTER JOIN (SELECT ODGCODE, SUM(ODQTY) AS TOTALQTY
                              FROM ORDERS
                              GROUP BY ODGCODE) OD
             ON G.GCODE = OD.ODGCODE
ORDER BY NVL(OD.TOTALQTY,0) DESC;
             
SELECT G.*, NVL(OD.TOTALQTY,0) AS TOTALQTY
FROM GOODS G LEFT OUTER JOIN (SELECT ODGCODE, SUM(ODQTY) AS TOTALQTY
                              FROM ORDERS
                              GROUP BY ODGCODE) OD
             ON G.GCODE = OD.ODGCODE
ORDER BY TOTALQTY DESC;

SELECT G.*, NVL(OD.TOTALQTY,0) AS TOTALQTY
FROM GOODS G LEFT OUTER JOIN (SELECT ODGCODE, SUM(ODQTY) AS TOTALQTY
                              FROM ORDERS
                              GROUP BY ODGCODE) OD
             ON G.GCODE = OD.ODGCODE
ORDER BY TOTALQTY DESC, G.GPRICE;

/* 메출액이 가장 높은 상품 순으로 정렬 */
--1. 상품별 매출액 조회 - ORDERS.ODQTY * GOODS.GPRICE
SELECT OD.ODGCODE, SUM(OD.ODQTY*G.GRPRICE) AS TOTALPRICE
FROM ORDERS OD, GOODS G
WHERE OD.ODGCODE = G.GCDE
GROUP BY OD.ODGCODE;

--2. 상품을 매출액 순으로 정렬
SELECT G.*, NVL(OD.TOTALPRICE,0) AS TOTALPRICE
FROM GOODS G LEFT OUTER JOIN (SELECT OD.ODGCODE, SUM(OD.ODQTY*G.GPRICE) AS TOTALPRICE
                              FROM ORDERS OD, GOODS G
                              WHERE OD.ODGCODE = G.GCODE
                              GROUP BY OD.ODGCODE) OD
            ON G.GCODE = OD.ODGCODE
ORDER BY TOTALPRICE DESC;

SELECT ROWNUM, G.*
FROM (SELECT G.*, NVL(OD.TOTALPRICE,0) AS TOTALPRICE
      FROM GOODS G LEFT OUTER JOIN (SELECT OD.ODGCODE, SUM(OD.ODQTY*G.GPRICE) AS TOTALPRICE
                              FROM ORDERS OD, GOODS G
                              WHERE OD.ODGCODE = G.GCODE
                              GROUP BY OD.ODGCODE) OD
            ON G.GCODE = OD.ODGCODE
      ORDER BY TOTALPRICE DESC) G; -- 

-- ROWNUM
SELECT ROWNUM, GOODS.*
FROM GOODS;

SELECT ROWNUM, GOODS.*
FROM GOODS
ORDER BY GPRICE DESC;

SELECT GOODS.*
FROM GOODS
ORDER BY GPRICE DESC; -- GPRICE를 기준으로 정렬

SELECT ROWNUM RN, GOODS.*
FROM (SELECT GOODS.*
      FROM GOODS
      ORDER BY GPRICE DESC) GOODS; -- GPRICE를 기준으로 정렬한것을 서브쿼리로 쓰고 ROWNUM을 이용해 위에서부터 순서대로 번호를 넣어준다(그럼 가장 비싼것부터 순위를 설정할 수 있다)

SELECT ROWNUM RN, GOODS.*
FROM (SELECT GOODS.*
      FROM GOODS
      ORDER BY GPRICE DESC) GOODS
WHERE ROWNUM BETWEEN 11 AND 20; -- 레코드가 안나옴

SELECT *
FROM(SELECT ROWNUM RN, GOODS.*
     FROM (SELECT GOODS.*
     FROM GOODS
     ORDER BY GPRICE DESC) GOODS)
WHERE RN BETWEEN 11 AND 20; -- GPRICE에 ROWNUM이 11~20까지를 조회

-- 상품을 매출액 순으로 정렬하고 제일 높은것 부터 순위설정
SELECT ROWNUM AS RK, G.*
FROM (SELECT G.*, NVL(OD.TOTALPRICE,0) AS TOTALPRICE
      FROM GOODS G LEFT OUTER JOIN (SELECT OD.ODGCODE, SUM(OD.ODQTY*G.GPRICE) AS TOTALPRICE
                              FROM ORDERS OD, GOODS G
                              WHERE OD.ODGCODE = G.GCODE
                              GROUP BY OD.ODGCODE) OD
            ON G.GCODE = OD.ODGCODE
      ORDER BY TOTALPRICE DESC) G;

-- 상품을 매출액 순위로 정렬한 것을 뷰를 이용에 하나의 가상의 테이블로 만들어서 쿼리문을 더 쉽게 작성할 수 있다
CREATE VIEW SALESRK
AS (SELECT ROWNUM AS RK, G.*
FROM (SELECT G.*, NVL(OD.TOTALPRICE,0) AS TOTALPRICE
      FROM GOODS G LEFT OUTER JOIN (SELECT OD.ODGCODE, SUM(OD.ODQTY*G.GPRICE) AS TOTALPRICE
                              FROM ORDERS OD, GOODS G
                              WHERE OD.ODGCODE = G.GCODE
                              GROUP BY OD.ODGCODE) OD
            ON G.GCODE = OD.ODGCODE
      ORDER BY TOTALPRICE DESC) G);

SELECT *
FROM SALESRK
WHERE RK BETWEEN 2 AND 5;

/* 가상테이블(VIEW)
CREATE VIEW -- 생성
CREATE OR REPLACE VIEW - 변경?
*/
CREATE OR REPLACE VIEW TESTVIEW1
AS (SELECT GCODE, GNAME FROM GOODS)
WITH READ ONLY; -- 읽기전용(조회만 가능)

CREATE OR REPLACE VIEW TESTVIEW1
AS (SELECT GCODE, GNAME FROM GOODS);

CREATE OR REPLACE VIEW TESTVIEW1
AS (SELECT * FROM GOODS G INNER JOIN ORDERS OD ON G.GCODE = OD.ODGCODE);

SELECT *
FROM TESTVIEW1;

UPDATE GOODS
SET GNAME = 'BANANAMILK'
WHERE GCODE = 'G0115';

UPDATE GOODS
SET GNAME = '바나나우유'
WHERE GCODE = 'G0115';

/* ORDERS, GOODS, MEMBERS 테이블을 INNER JOIN 한 VIEW 생성 */
SELECT * FROM ORDERS;
SELECT * FROM GOODS;
SELECT * FROM MEMBERS;

CREATE OR REPLACE VIEW SALESVIEW
AS (SELECT *
    FROM ORDERS OD INNER JOIN GOODS G 
                   ON OD.ODGCODE = G.GCODE 
                   INNER JOIN MEMBERS M 
                   ON M.MID = OD.ODMID);

SELECT * FROM SALESVIEW;

SELECT GNAME, MNAME
FROM SALESVIEW
WHERE TO_CHAR(ODDATE, 'YYYY-MM-DD') = '2023-06-01';


-----day12

-- DB12.sql


-----day13

/* ORACLE - 문자 함수
TO_CHAR() - 날짜형 >> 문자형
TO_DATE() - 문자형 >> 날짜형
UPPER() - 모두 대문자로 변경
LOWER() - 모두 소문자로 변경
*/
SELECT UPPER('student'), LOWER('STUDENT')
FROM DUAL;

SELECT *
FROM EMP
WHERE ENAME = 'ALLEN';

SELECT *
FROM EMP
WHERE ENAME = 'allen';

SELECT *
FROM EMP
WHERE UPPER(ENAME) = UPPER('allen');

SELECT *
FROM EMP
WHERE LOWER(ENAME) = LOWER('allen');

-- INITCAP() : 첫글자를 대문자로, 나머지는 소문자로
SELECT INITCAP('STUDENT'), INITCAP('student'), INITCAP('stUDent')
FROM DUAL;

-- LENCTH() : 문자열의 길이를 확인
SELECT LENGTH('STUDENT') FROM DUAL;
SELECT ENAME, LENGTH(ENAME) 
FROM EMP;

SELECT MID, LENGTH(MID) 
FROM MEMBERS;

-- LENGTHB() : 문자의 BYTE 확인
SELECT LENGTH('STUDENT'), LENGTHB('STUDENT') FROM DUAL;
SELECT LENGTH('학생'), LENGTHB('학생'), LENGTH('학'), LENGTHB(ㅎ') FROM DUAL;

-- SUBSTR(문자형데이터, 시작위치, 글자수) : 문자열의 일부를 추출

SELECT SUBSTR('STUDENT', 1), SUBSTR('STUDENT', 3)
FROM DUAL;
SELECT SUBSTR('STUDENT', 3, 2) -- UD
FROM DUAL;
SELECT SUBSTR(ENAME, 2), SUBSTR(ENAME, 2,2)
FROM EMP;

-- INSTR('문자형데이터','찾을문자', '시작위치')
SELECT INSTR('STUDENAT', 'T'), INSTR('STUDENAT', 'T',3)
FROM DUAL;

SELECT INSTR('STUDENAT', 'DEN'), INSTR('STUDENAT', 'Z'), INSTR('STUDENAT', 'SUT')
FROM DUAL;

-- REPLACE('문자형데이터', '대상문자','변경할문자') : 특정 문자를 바꾸는 함수
SELECT REPLACE('010-1111-2222', '-', '*')
FROM DUAL;
SELECT ENAME, REPLACE(ENAME, 'A', '에이')
FROM EMP;
SELECT ENAME, REPLACE(ENAME, 'A','')
FROM EMP;

-- LPAD(문자형데이터, 전체글자수, '채워줄문자')
-- RPAD()

SELECT LPAD('STU', 10, '-'), RPAD('STU',10,'-')
FROM DUAL;

SELECT LPAD('STUDENT', 5, '-'), RPAD('STU',10,'-')
FROM DUAL;

-- '230607-3456789' 조회 결과>> '230607-3*******' 출력
SELECT '230607-3456789', RPAD('230607-3',14,'*')
FROM DUAL;
SELECT '230607-3456789', RPAD( SUBSTR('230607-3456789',1,8),14,'*')
FROM DUAL;

-- 'ㅇㅇㅇ' >> 'ㅇ*ㅇ'(이름)
SELECT MNAME
FROM MEMBERS;
SELECT MNAME, REPLACE(MNAME, SUBSTR(MNAME,2,1), '*')
FROM MEMBERS;


-----day14
/* 숫자 함수 */
-- 절대값
SELECT ABS(5), ABS(-10) FROM DUAL;

-- 반올림 : ROUND(숫자, 소수점자리수)
SELECT 1234.5678, ROUND(1234.5678), ROUND(1234.5678, 0), ROUND(1234.5678, 1) FROM DUAL;
SELECT 1234.5678, ROUND(1234.5678, -1), ROUND(1234.5678, -2) FROM DUAL;

-- 버림 : TRUNC(숫자, 소수점자리수)
SELECT 1234.5678, TRUNC(1234.5678), TRUNC(1234.5678, 0), TRUNC(1234.5678, 1) FROM DUAL;
SELECT 1234.5678, TRUNC(1234.5678, -1), TRUNC(1234.5678, -2) FROM DUAL;

-- CEIL(숫자) : 지정된 숫자보다 큰 정수(올림)
-- FLOOR(숫자) : 지정된 숫자보다 작은 정수
SELECT 1234.5678, CEIL(1234.5678), FLOOR(1234.5678) FROM DUAL;

/* 날짜형 */
SELECT SYSDATE AS 현재시간, (SYSDATE - 1) AS 하루전, (SYSDATE + 1) AS 다음날 FROM DUAL;
SELECT SYSDATE AS 현재시간, (SYSDATE - 1/24) AS 한시간전, (SYSDATE + 1/24) AS 한시간후 FROM DUAL;
SELECT SYSDATE AS 현재시간, (SYSDATE - 30/24/60) AS 삼십분전 FROM DUAL;
SELECT SYSDATE AS 현재시간, (SYSDATE - 11/24/60) AS 십일분전 FROM DUAL;

-- ADD_MONTHS(날짜형, 개월수)
SELECT ADD_MONTHS(SYSDATE, 2) FROM DUAL;

SELECT SYSDATE - ODDATE, SYSDATE, ODDATE FROM ORDERS;

SELECT ODDATE - SYSDATE, SYSDATE, ODDATE FROM ORDERS;

-- MONTHS_BETWEEN(날짜형, 날짜형) : 두날짜의 개월차
SELECT MONTHS_BETWEEN(SYSDATE, '2023-01-10') FROM DUAL;

SELECT MONTHS_BETWEEN('2023-01-10', SYSDATE) FROM DUAL;

-- NEXT_DAY(날짜, 찾을 요일) : 기준이 되는 날짜부터 찾을 요일
SELECT NEXT_DAY(SYSDATE, '월') FROM DUAL;

-- LAST_DAY(날짜)
SELECT LAST_DAY(SYSDATE), LAST_DAY('2023-07-01') FROM DUAL;

-- TO_CHAR()
SELECT ODDATE, TO_CHAR(ODDATE, 'YYYY') AS 연도,  
               TO_CHAR(ODDATE, 'MM') AS 월,
               TO_CHAR(ODDATE, 'DD') AS 일,
               TO_CHAR(ODDATE, 'HH24') AS 시
FROM ORDERS;

SELECT ODDATE, 
        TO_CHAR(ODDATE, 'MON'),
        TO_CHAR(ODDATE, 'DAY'), -- 무슨 요일인지(목요일)
        TO_CHAR(ODDATE, 'DY'), -- 요일(목)
        TO_CHAR(ODDATE, 'W'),
        TO_CHAR(ODDATE, 'WW'),
        TO_CHAR(SYSDATE, 'W')
FROM ORDERS;

-- NVL(컬럼, 대체값) : NULL 값대체
-- NVL2(컬럼, NULL이 아닌경우, NULL인 경우)
SELECT ENAME ,COMM, NVL(COMM, 10000) FROM EMP;

SELECT ENAME ,COMM, NVL2(COMM, 'COMM있음', 'COMM없음') FROM EMP;



---------------------------------------------------------------------
--SYS계정으로 접속 후 실행
ALTER SESSION SET "_ORACLE_SCRIPT" = TRUE;
CREATE USER MOVIEPROJECT IDENTIFIED BY"1111";
GRANT DBA TO MOVIEPROJECT;

DROP USER MOVIEPROJECT;

-- SYS계정 접속해제
-- MOVIEPROJECT 접속 후 실행

/* 영화정보 테이블(MOVIES - MV) */
CREATE TABLE MOVIES(
    MVCODE NCHAR(7),            -- 코드()
    MVTITLE NVARCHAR2(50),      -- 제목
    MVDIRECTOR NVARCHAR2(30),   -- 감독
    MVACTORS NVARCHAR2(200),    -- 배우
    MVGENRE NVARCHAR2(200),     -- 장르
    MVINFO NVARCHAR2(200),      -- 기본정보
    MVOPEN DATE,                -- 개봉일
    MVPOSTER NVARCHAR2(200),    -- 포스터URL
    MVSTATE NCHAR(1)            -- 상태(1:가능,0:중지)
);








